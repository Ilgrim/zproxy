#!/usr/bin/perl

# USAGE DOCUMENTATION:
#
# Options:
# -http_cfg_file : Path to the config file used by zhttp in the HTTP tests. Default: test_http.cfg
# -https_cfg_file : Path to the config file used by zhttp in the HTTPS tests. Default: test_https.cfg
# -ip : Destination IP/URL used to do the requests. Default: localhost
# -port : Port used to do the requests in the HTTP tests. Default: 8000
# -port_https : Port used to do the requests in the HTTPS tests. Default: 8443
# -post_file : Path to the custom file to be send in the POST request tests. Default: data/test_text.txt
# -binary : Path to the zhttp binary. Default: ../build/bin/zhttp
# -https : If this flag is set the HTTPS tests are going to be executed.
# -no_zhttp : If this flag is set, zhttp is not going to be launched.
# -control : Path to the control socket used to test de API. Default: /tmp/zhttp.socket

# REQUIREMENTS:
#
# In order to run the functional tests you will need to install the following perl packages:
#
# Term::ANSIColor
# JSON
# Getopt::Long (It should be installed by default.)
# Digest::MD5
# Digest::MD5::File
#
# In addition, you will need "curl" and "Perl5" installed in your system.

use Getopt::Long 'GetOptions';
use JSON qw(decode_json);
use Digest::MD5 qw(md5_hex);
use Digest::MD5::File qw(file_md5_hex);
use Term::ANSIColor;

my $zhttp_cfg = 'test_http.cfg';
my $zhttps_cfg = 'test_https.cfg';
my $ip = 'localhost';
my $port = '8000';
my $port_https = '8443';
my $file_path = 'data/test_text.txt';
my $binary = '../build/bin/zhttp';
my $control_socket = '/tmp/zhttp.socket';
GetOptions(
    'post_file=s' => \$file_path,
    'http_cfg_file=s' => \$zhttp_cfg,
    'https_cfg_file=s' => \$zhttps_cfg,
    'https' => \my $https,
    'no_zhttp' => \my $no_zhttp,
    'ip=s' => \$ip,
    'port=s' => \$port,
    'port_https=s' => \$port_https,
    'binary=s' => \$binary,
    'control=s' => \$control_socket,
);

run_docker();
if (!$no_zhttp) {
    run_zhttp($zhttp_cfg);
}
test_get_200_ok();
test_check_POST_file();
if (!$no_zhttp) {
    test_disable_service();
    test_disable_backend();
    test_disable_service_fail();
    test_disable_backend_fail();
    test_enable_backend();
    test_enable_service();
    stop_zhttp();
}

if ($https) {
    print "Starting HTTPS tests \n";
    if (!$no_zhttp) {
        run_zhttp($zhttps_cfg);
    }
    test_get_200_ok_https();
    test_check_POST_file_https();
    if (!$no_zhttp) {
        stop_zhttp();
    }
}
stop_docker();

sub run_zhttp {
    my ($cfg) = @_;
    system("$binary -f $cfg");
    sleep(4);
}

sub stop_zhttp {
    my $cmd = `pkill -9 $binary -f`;
}

sub run_docker {

    print "Starting docker container..\n";
    # The docker container comes from https://github.com/mendhak/docker-http-https-echo
    $docker_id = `sudo docker run -d -p 8080:80 -p 8443:443 --rm -t mendhak/http-https-echo`;
    sleep(2);
}

sub stop_docker {

    my $stop_log = `sudo docker stop $docker_id`;
    if ($stop_log == $docker_id) {
        print "Docker is now stopped.\n";
    }
}

sub assert_equal {

    my ($p1, $p2, $test_description) = @_;

    if ($p1 == $p2) {
        print "Test $test_description [",  color("bold green"), "PASS", color("reset"), "]\n";
    } else {
        print "Test $test_description [", color("bold red"), "FAIL", color("reset"), "]\n";
    }
}

sub test_check_POST_file {

    my $response = `curl -s --data-binary "\@${file_path}" -H "Expect: " http://${ip}:${port}`;
    my $decoded = decode_json($response);
    my $file_crc = file_md5_hex($file_path);
    my $crc = $decoded->{'body'};

    assert_equal($crc, $file_crc, "POST file checksum");
}

sub test_get_200_ok {
    my $response = `curl -s http://${ip}:${port}`;
    my $decoded = decode_json($response);

    assert_equal($decoded->{'method'}, "GET", "GET method");
}

sub test_check_POST_file_https {
    my $response = `curl -s -k --data-binary "\@${file_path}" -H "Expect: " https://${ip}:${port_https}`;
    my $decoded = decode_json($response);
    my $file_crc = file_md5_hex($file_path);
    my $crc = $decoded->{'body'};

    assert_equal($crc, $file_crc, "POST file https");
}

sub test_get_200_ok_https {
    my $response = `curl -s -k https://${ip}:${port_https}`;
    my $decoded = decode_json($response);

    assert_equal($decoded->{'method'}, "GET", "GET method HTTPS");
}

sub test_disable_backend {
    my $response = `curl -s -X PATCH --data-ascii '{status: "down"}' --unix-socket ${control_socket} http://${ip}/listener/0/service/0/backend/0/status`;
    my $decoded = decode_json($response);

    assert_equal($decoded->{'result'}, "ok", "API disable backend");
}

sub test_disable_service {
    my $response = `curl -s -X PATCH --data-ascii '{status: "down"}' --unix-socket ${control_socket} http://${ip}/listener/0/service/0/status`;
    my $decoded = decode_json($response);

    assert_equal($decoded->{'result'}, "ok", "API disable service");
}

sub test_disable_service_fail {
    my $response = `curl -s -X PATCH --data-ascii '{status: "down"}' --unix-socket ${control_socket} http://${ip}/listener/0/service/200/status`;
    my $decoded = decode_json($response);

    assert_equal($decoded->{'result'}, "error", "API disable wrong service");
}

sub test_disable_backend_fail {
    my $response = `curl -s -X PATCH --data-ascii '{status: "down"}' --unix-socket ${control_socket} http://${ip}/listener/0/service/0/backend/1000/status`;
    my $decoded = decode_json($response);

    assert_equal($decoded->{'result'}, "fail", "API disable wrong backend");
}

sub test_enable_backend {
    my $response = `curl -s -X PATCH --data-ascii '{status: "up"}' --unix-socket ${control_socket} http://${ip}/listener/0/service/0/backend/0/status`;
    my $decoded = decode_json($response);

    assert_equal($decoded->{'result'}, "ok", "API enable backend");
}

sub test_enable_service {
    my $response = `curl -s -X PATCH --data-ascii '{status: "up"}' --unix-socket ${control_socket} http://${ip}/listener/0/service/0/status`;
    my $decoded = decode_json($response);

    assert_equal($decoded->{'result'}, "ok", "API enable service");
}
